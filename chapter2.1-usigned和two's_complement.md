### 整数表示的一些知识

1. 由于浮点数不精确，只是表示一个近似的数。而整数精确，所以特殊情况下，浮点数不符合结合律
    - (3.14+1e20) - 1e20 == 0
    - 3.14 + (1e20-1e20) == 3.14
2. 大多数机器使用字节作为最小的可寻址的内存单元。机器级程序将内存视为巨大的字节数组，称为<font color=#00ffff>虚拟内存</font>，内存中的每个字节都由<font color=#00ffff>唯一的地址</font>来标识。所有可能的地址的集合就叫做<font color=#00ffff>虚拟地址空间</font>。
3. hex
    - hex(hexadecimal):0x1234或者0X1234(c语言中)
    - binary和hex转化
    - hex和dec转化
4. 计算机的<font color=#00ffff>字长（word size）指的就是指针的标称大小（nominal size）</font>。也就是虚拟地址空间的最大大小。
    1. 字长64位的机器也可以兼容字长32位的程序
    2. gcc -m32 prog.c //可以在64位机器或者32位机器运行，反之则不行
    3. 因此，我们称的32位程序指的是他的编译方式，而不是所运行的机器

5. c语言所写的程序，(unsigned) char是1字节，(unsigned) short是2字节，(unsigned) int 是4字节，(unsigned) long在32位程序和64位程序上分别是4字节和8字节。int32_t，uint32_t, int64_t, uint64_t这些设计出来就是为了适应这个问题。char *（指针）在32位程序和64位程序上不同，float是4字节，double是8字节。

6. C语言中，long int，unsigned long int， long unsigned int都是合法的
7. 大端法(big endian)和小端法(little endian)
    - 例子：0X01234567
    - 大端法：更重要的字节放在前面，自然一点
    - 小端法：更重要的字节放在后面，逆序了
    - 大多数intel兼容机使用小端法，安卓和IOS使用小端法
8. printf
    - %d十进制，%u无符号数10进制，%f浮点数，%c字符，%x十六进制，%.2x至少用两位
9. man ascii生成ascii表，小技巧
10. c语言表示字符串
    - char * s = "abc";
    - 实质上有4个顺序字节, 61, 62, 63, 0
11. 位运算与或非，异或
    - & | ~ ^，对于多个二进制位数适用
    - 异或存在交换，结合
    - 任何数与1异或，变相反；任何数与0异或，不变
    - 异或可以原地交换
12. 逻辑运算与或非，&&, ||, !
    - 只会返回0或1
13. 移位
    - x\>>4 ,x << 4
    - c语言无明确规定逻辑，算术，但无符号数使用逻辑移位，有符号数使用算术移位
    - java >> 算数， >>>逻辑
    - 移位会取模，例如 x >> 68
    - 移位优先级比加法低
14. 二进制，无符号数(unsigned)
    - 一一对应，是双射函数
    - $Umin = 0,  Umax = 2^w-1$
15. 二进制，补码(two's complement)
    - 二进制->补码表示：最高位为负权值，其他为正权值
    - 也是双射函数
    - $TMin = - 2^{w-1}, Tmax = 2^{w-1}-1$
16. 十进制数与补码转化(考试要求)
    - 十进制数先化为原码，若是正数，则完成
    - 若是负数，符号位不变，其他取反，末位加1
    - 补码转化为十进制数，一个操作
17. c头文件，limit.h，有INT_MAX等常量
18. 0x, 0b, 0, 0是8进制; 12345u,表示无符号数
19. 同样二进制位的补码和无符号数关系
    - 若为正数，两者相同
    - 若补码为负数，则$T2U(x) = x + 2^w$
20. 同样二进制位的无符号数转化为补码
    - 若小于等于Tmax，那么是一样的
    - 若大于Tmax, $U2T(x) = u - 2^w$
21. 隐式转换
    - 大多数隐式转换都如你所想那样
    - 一种例外：计算时，若有一个有符号，一个无符号，那么计算机会隐式转换成两个无符号数，例如-1 > 0u是true
22. 符号扩展
    - 无符号数，补0
    - 补码，若为正数，自然补0
    - 补码，若为负数，补1，简单证明（举个例子就OK了）
    - 值得一提的是，当short转换为unsigned（int）时，是先符号扩展，再转为无符号数
    - <font color=#00ff>也就是按照原类型变长</font>
23. 截断
    - int 转换为short，unsigned short等



