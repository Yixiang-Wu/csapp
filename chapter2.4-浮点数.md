1. 形式如同$0.111...11_2$表示刚好小于1的数，这里用简单的表示法：$1.0-\varepsilon$
2. 使用浮点数
    - 使用定点数表示法，不方便，位数太长，例如$5 * 2^{100}$就要101后面加上100个0，所以用浮点数
    - 符号sign，尾数significand，阶码exponent
    - 符号域s，阶数域exp，尾数域frac
    - 单精度（float），31, 30<-23, 22<-0, 比率是1：8：23
    - 双精度（double），63，62<-52, 51<-0, 比率是1：11：52
3. 单精度，一些分类
    1. 规格化（normalized）：阶数域不为0，不为255
    2. 非规格化（denormalized）：阶数域为0
    3. 无穷大（infinity）：阶数域为255，尾数域全0
    4. NaN（Not a Number）：阶数域255，尾数域不全为0
4. 分类详解
    1. 规格化：令$Bias = 2^{k-1} - 1$，例如在单精度中，$Bias = 127$，则阶码E范围等于 （$1到254 - 127 = -126到127$），尾数域为f，尾数$M = 1 + f$，则该浮点数值等于$M * 2^E$
    2. 非规格化：阶码$E = 1 - Bias$，尾数$M = f$，浮点数值等于$M *2^E$。非规格化可以表示0，有+0和-0；也可以表示0附近的极小值。
    3. 阶数域为255时，表示特殊值，其中无穷大有正无穷和负无穷，由sign区别
    4. NaN用在特殊情况，例如除数为0，根号－1，无穷减无穷等情况
5. 设计的巧妙性
    - 观察非规格化，规格化，无穷大的浮点数，可以看到，其恰好是按照无符号数的大小排列。因此可以不需要浮点计算就能进行大小排列。
    - 负数看2.84
6. 假设尾数域有n位，那么最小的不能正确表示的正整数，应该是什么形式
    - 1 + n个0 + 1

### rounding
1. 原因
    - 因为表示方式的限制，浮点数往往不能确切地表示数$x$，所以我们需要使用舍入来找到一个近似的值$x'$来表示$x$，这就是舍入。
2. 几种舍入方法的介绍
    1. 向偶数舍入(round to even)，向最接近值舍入(round to nearest)
        - 十进制：例如1.4,1.5,1.6,2.5，要舍入到个位。1.4和1.6不是中间值(1.5)，所以分别舍入到1和2。1.5和2.5是中间值，所以看最低有效位（个位）是不是偶数，则分别舍入到2和2。负数是一个道理。
        - 二进制：举例舍入到1/4，或者说舍入到小数点后2位。对于10.00011-->10.00, 10.00110-->10.01，这两个例子不是中间值；对于10.00100-->10.00, 10.01100-->10.10。
    2. 向零舍入
        - 无论正数还是负数，都向0的方向进行舍入。正数向下舍入，负数向上舍入。
    3. 向上舍入
    4. 向下舍入
3. 舍入方式的选择
    - 第2，3，4种舍入方式会产生实际值的确界（guaranteed bound），这在一些数学应用中很有用。第1种方法的优点是在50%的时间会向上舍入，在50%的时间会向下舍入，从统计学的角度讲，平均值不会偏高，不会偏低，所以，IEEE定的标准默认使用向偶数舍入。


### 小结
1. 浮点数由于精度的问题（没有结合律），在科学计算中可能存在巨大挑战
2. 在C语言种，math.h定义了INFINITY和NAN
3. int,float,double转化
    1. int-->float，可能会舍入
    2. int,float-->double,没问题
    3. double-->float,可能溢出到$\infty$,也可能舍入
    4. float，double-->int,会向零舍入。在intel兼容的处理器中，若找不到合适的匹配值，会产生TMin