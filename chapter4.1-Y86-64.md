## ISA
- 定义一个ISA，需要包括定义各种状态单元（寄存器等），定义指令集和它们的编码，一组编程规范和异常事件处理。
------
## 程序员可见状态
- 说明
  1. 处理器实现时，不需要按照定义的样子实现，只需要保证可以正常访问就OK
  2. 总共有15个程序寄存器，之所以不加r15，是因为 0x0~0xF。每个寄存器保存64位
  3. 有虚拟地址，但目前不讨论
![](./附件/Y86-64状态.png)
------
## 指令
- 说明
  1. 内存寻址方式只使用基址+偏移量的形式
  2. 同x86一样，不允许内存->内存。另外，与x86不同的是，Y86不允许立即数->内存
  3. OPq只允许对寄存器进行操作，会设置ZF,SF,OF
  4. halt相当于x86中的hlt。在x86中，应用程序不允许使用hlt；在Y86中，执行halt会导致处理器停止，并将状态码设置为HLT
  5. 只有64位的数
![](./附件/Y86-64指令集.png)
------
## 指令编码（用于查询）
- 功能码中高4位为代码（code），低4位为功能（function）。
- 其他说明
  1. 分支指令和调用指令的目的是绝对地址
  2. 采用小端法
![](./附件/Y86-64指令集的功能码.png)
![](./附件/Y86-64程序寄存器.png)
------
## RISC CISC
- Y86-64两者的特点都有一些
![](./附件/RISC&CISC.png)
------
## Y86-64的异常
- 当遇到时，Y86会让处理器停止。在真实情况中，会有异常处理程序
![](./附件/Y86-64异常.png)
------
## 实例研究Y86-64程序
- 结论
1. Y86会将立即数放入寄存器，然后使用OPq; x86则可以直接立即数和寄存器运算。
2. 汇编伪指令（assembler directive）
  - 告诉汇编器调整地址，以便在那里产生代码或插入一些数据
  - .align, .quad, .pos等
  - 了解意思即可，不深究
3. 汇编器YAS，指令集模拟器YIS
------
## pushq和popq的奇葩用法
- 说明：x86和Y86一样
1. pushq rsp
``` C
// 把rsp的原始值放入(rsp)了
temp = rsp
rsp -= 8
(rsp) = temp
```
2. popq rsp
``` C
rsp = (rsp)
```
